const Product = require('../models/Product');
const Store = require('../models/Store');
const Category = require('../models/Category');
const SubCategory = require('../models/SubCategory');
const { Op } = require('sequelize');
const multer = require('multer');
const path = require('path');
const fs = require('fs').promises;

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = 'uploads/products';
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif|webp|mp4|avi|mov|wmv|flv|webm/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);
  
  if (mimetype && extname) {
    return cb(null, true);
  } else {
    cb(new Error('Only image and video files are allowed!'));
  }
};

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: fileFilter
});

// Helper function to generate slug
const generateSlug = (name) => {
  return name.toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim('-');
};

// Helper function to handle file uploads
const handleFileUpload = async (file, fieldName) => {
  if (!file) return null;
  
  try {
    const filePath = file.path.replace(/\\/g, '/'); // Normalize path for cross-platform
    return filePath;
  } catch (error) {
    console.error(`Error handling ${fieldName} upload:`, error);
    return null;
  }
};

// Helper function to delete old files
const deleteOldFiles = async (product, newData) => {
  const fieldsToCheck = [
    'image_1', 'image_2', 'image_3', 'image_4', 'image_5',
    'image_6', 'image_7', 'image_8', 'image_9', 'image_10',
    'video_1', 'video_2', 'size_chart'
  ];
  
  for (const field of fieldsToCheck) {
    if (newData[field] && product[field] && newData[field] !== product[field]) {
      try {
        if (product[field] && fs.existsSync(product[field])) {
          await fs.unlink(product[field]);
        }
      } catch (error) {
        console.error(`Error deleting old ${field}:`, error);
      }
    }
  }
};

// Get all products with pagination and search
exports.getProducts = async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      search = '', 
      store_id = '', 
      category_id = '', 
      sub_category_id = '',
      min_price = '',
      max_price = '',
      is_active = '',
      is_featured = ''
    } = req.query;
    const offset = (page - 1) * limit;
    
    // Build where clause
    const whereClause = {};
    if (search) {
      whereClause[Op.or] = [
        { name: { [Op.like]: `%${search}%` } },
        { description: { [Op.like]: `%${search}%` } },
        { product_code: { [Op.like]: `%${search}%` } },
        { sku_id: { [Op.like]: `%${search}%` } }
      ];
    }
    
    if (store_id) {
      whereClause.store_id = store_id;
    }
    
    if (category_id) {
      whereClause.category_id = category_id;
    }
    
    if (sub_category_id) {
      whereClause.sub_category_id = sub_category_id;
    }
    
    if (min_price !== '' || max_price !== '') {
      whereClause.selling_price = {};
      if (min_price !== '') {
        whereClause.selling_price[Op.gte] = parseFloat(min_price);
      }
      if (max_price !== '') {
        whereClause.selling_price[Op.lte] = parseFloat(max_price);
      }
    }
    
    if (is_active !== '') {
      whereClause.is_active = is_active === 'true';
    }
    
    if (is_featured !== '') {
      whereClause.is_featured = is_featured === 'true';
    }
    
    // Get products with count
    const { count, rows: products } = await Product.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [['createdAt', 'DESC']],
      include: [
        {
          model: Store,
          as: 'store',
          attributes: ['id', 'name', 'logo']
        },
        {
          model: Category,
          as: 'category',
          attributes: ['id', 'name']
        },
        {
          model: SubCategory,
          as: 'subCategory',
          attributes: ['id', 'name']
        }
      ]
    });
    
    res.json({
      success: true,
      data: {
        products,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(count / limit),
          totalItems: count,
          itemsPerPage: parseInt(limit)
        }
      }
    });
  } catch (error) {
    console.error('Get products error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch products',
      error: error.message
    });
  }
};

// Create new product with image/video uploads
exports.createProduct = async (req, res) => {
  try {
    const productData = req.body;
    
    // Validate required fields
    if (!productData.name || !productData.product_code || !productData.selling_price || !productData.store_id) {
      return res.status(400).json({
        success: false,
        message: 'Name, product code, selling price, and store are required'
      });
    }
    
    // Check if product code already exists
    const existingProduct = await Product.findOne({ 
      where: { product_code: productData.product_code } 
    });
    if (existingProduct) {
      return res.status(400).json({
        success: false,
        message: 'Product with this code already exists'
      });
    }
    
    // Check if store exists
    const store = await Store.findByPk(productData.store_id);
    if (!store) {
      return res.status(400).json({
        success: false,
        message: 'Store not found'
      });
    }
    
    // Generate slug
    productData.slug = generateSlug(productData.name);
    
    // Handle file uploads
    if (req.files) {
      // Handle multiple images
      for (let i = 1; i <= 10; i++) {
        if (req.files[`image_${i}`]) {
          productData[`image_${i}`] = await handleFileUpload(req.files[`image_${i}`], `image_${i}`);
        }
      }
      
      // Handle videos
      if (req.files.video_1) {
        productData.video_1 = await handleFileUpload(req.files.video_1, 'video_1');
      }
      if (req.files.video_2) {
        productData.video_2 = await handleFileUpload(req.files.video_2, 'video_2');
      }
      
      // Handle size chart
      if (req.files.size_chart) {
        productData.size_chart = await handleFileUpload(req.files.size_chart, 'size_chart');
      }
    }
    
    // Create product
    const product = await Product.create(productData);
    
    res.status(201).json({
      success: true,
      message: 'Product created successfully',
      data: product
    });
  } catch (error) {
    console.error('Create product error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create product',
      error: error.message
    });
  }
};

// Update product with image/video management
exports.updateProduct = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;
    
    // Find product
    const product = await Product.findByPk(id);
    if (!product) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }
    
    // Check if product code is being changed and if it already exists
    if (updateData.product_code && updateData.product_code !== product.product_code) {
      const existingProduct = await Product.findOne({ 
        where: { product_code: updateData.product_code, id: { [Op.ne]: id } } 
      });
      if (existingProduct) {
        return res.status(400).json({
          success: false,
          message: 'Product with this code already exists'
        });
      }
    }
    
    // Generate new slug if name changed
    if (updateData.name && updateData.name !== product.name) {
      updateData.slug = generateSlug(updateData.name);
    }
    
    // Handle file uploads
    if (req.files) {
      // Handle multiple images
      for (let i = 1; i <= 10; i++) {
        if (req.files[`image_${i}`]) {
          updateData[`image_${i}`] = await handleFileUpload(req.files[`image_${i}`], `image_${i}`);
        }
      }
      
      // Handle videos
      if (req.files.video_1) {
        updateData.video_1 = await handleFileUpload(req.files.video_1, 'video_1');
      }
      if (req.files.video_2) {
        updateData.video_2 = await handleFileUpload(req.files.video_2, 'video_2');
      }
      
      // Handle size chart
      if (req.files.size_chart) {
        updateData.size_chart = await handleFileUpload(req.files.size_chart, 'size_chart');
      }
    }
    
    // Delete old files if new ones are uploaded
    await deleteOldFiles(product, updateData);
    
    // Update product
    await product.update(updateData);
    
    res.json({
      success: true,
      message: 'Product updated successfully',
      data: product
    });
  } catch (error) {
    console.error('Update product error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update product',
      error: error.message
    });
  }
};

// Delete product and associated files
exports.deleteProduct = async (req, res) => {
  try {
    const { id } = req.params;
    
    // Find product
    const product = await Product.findByPk(id);
    if (!product) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }
    
    // Delete associated files
    const fieldsToCheck = [
      'image_1', 'image_2', 'image_3', 'image_4', 'image_5',
      'image_6', 'image_7', 'image_8', 'image_9', 'image_10',
      'video_1', 'video_2', 'size_chart'
    ];
    
    for (const field of fieldsToCheck) {
      if (product[field]) {
        try {
          if (fs.existsSync(product[field])) {
            await fs.unlink(product[field]);
          }
        } catch (error) {
          console.error(`Error deleting ${field}:`, error);
        }
      }
    }
    
    // Delete product
    await product.destroy();
    
    res.json({
      success: true,
      message: 'Product deleted successfully'
    });
  } catch (error) {
    console.error('Delete product error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete product',
      error: error.message
    });
  }
};

// Bulk upload products from CSV
exports.bulkUploadProducts = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'CSV file is required'
      });
    }
    
    const { store_id } = req.body;
    if (!store_id) {
      return res.status(400).json({
        success: false,
        message: 'Store ID is required'
      });
    }
    
    // Check if store exists
    const store = await Store.findByPk(store_id);
    if (!store) {
      return res.status(400).json({
        success: false,
        message: 'Store not found'
      });
    }
    
    const results = [];
    const errors = [];
    let successCount = 0;
    let errorCount = 0;
    
    // Read CSV file
    fs.createReadStream(req.file.path)
      .pipe(csv())
      .on('data', async (row) => {
        try {
          // Map CSV columns to product fields
          const productData = {
            product_code: row['Product Code'] || row['product_code'],
            amazon_asin: row['Amazon ASIN'] || row['amazon_asin'],
            name: row['Name'] || row['name'],
            sku_id: row['Sku Id'] || row['sku_id'],
            description: row['Description'] || row['description'],
            selling_price: parseFloat(row['Selling Price'] || row['selling_price']) || 0,
            mrp: parseFloat(row['MRP'] || row['mrp']) || 0,
            cost_price: parseFloat(row['Cost Price'] || row['cost_price']) || 0,
            quantity: parseInt(row['Quantity'] || row['quantity']) || 0,
            packaging_length: parseFloat(row['Packaging Length (in cm)'] || row['packaging_length']) || null,
            packaging_breadth: parseFloat(row['Packaging Breadth (in cm)'] || row['packaging_breadth']) || null,
            packaging_height: parseFloat(row['Packaging Height (in cm)'] || row['packaging_height']) || null,
            packaging_weight: parseFloat(row['Packaging Weight (in kg)'] || row['packaging_weight']) || null,
            gst_percentage: parseFloat(row['GST %'] || row['gst_percentage']) || 0,
            image_1: row['Image 1'] || row['image_1'],
            image_2: row['Image 2'] || row['image_2'],
            image_3: row['Image 3'] || row['image_3'],
            image_4: row['Image 4'] || row['image_4'],
            image_5: row['Image 5'] || row['image_5'],
            image_6: row['Image 6'] || row['image_6'],
            image_7: row['Image 7'] || row['image_7'],
            image_8: row['Image 8'] || row['image_8'],
            image_9: row['Image 9'] || row['image_9'],
            image_10: row['Image 10'] || row['image_10'],
            video_1: row['Video 1'] || row['video_1'],
            video_2: row['Video 2'] || row['video_2'],
            product_type: row['Product Type'] || row['product_type'],
            size_type: row['Size Type'] || row['size_type'],
            size: row['Size'] || row['size'],
            colour: row['Colour'] || row['colour'],
            return_exchange_condition: row['Return/Exchange Condition'] || row['return_exchange_condition'],
            hsn_code: row['HSN Code'] || row['hsn_code'],
            customisation_id: row['Customisation Id'] || row['customisation_id'],
            associated_pixel: row['Associated Pixel'] || row['associated_pixel'],
            attr1_attribute_name: row['attr1_Attribute Name'] || row['attr1_attribute_name'],
            attr2_attribute_name: row['attr2_Attribute Name'] || row['attr2_attribute_name'],
            attr3_attribute_name: row['attr3_Attribute Name'] || row['attr3_attribute_name'],
            attr4_attribute_name: row['attr4_Attribute Name'] || row['attr4_attribute_name'],
            attr5_attribute_name: row['attr5_Attribute Name'] || row['attr5_attribute_name'],
            collection_1: row['collection_1'] || row['collection_1'],
            collection_2: row['collection_2'] || row['collection_2'],
            collection_3: row['collection_3'] || row['collection_3'],
            store_id: parseInt(store_id),
            slug: generateSlug(row['Name'] || row['name']),
            is_active: true
          };
          
          // Validate required fields
          if (!productData.name || !productData.product_code || productData.selling_price <= 0) {
            errors.push({
              row: row,
              error: 'Missing required fields: name, product_code, or selling_price'
            });
            errorCount++;
            return;
          }
          
          // Check if product code already exists
          const existingProduct = await Product.findOne({ 
            where: { product_code: productData.product_code } 
          });
          if (existingProduct) {
            errors.push({
              row: row,
              error: `Product code ${productData.product_code} already exists`
            });
            errorCount++;
            return;
          }
          
          // Create product
          const product = await Product.create(productData);
          results.push(product);
          successCount++;
          
        } catch (error) {
          errors.push({
            row: row,
            error: error.message
          });
          errorCount++;
        }
      })
      .on('end', async () => {
        // Clean up uploaded file
        fs.unlinkSync(req.file.path);
        
        // Update store product count
        await store.update({ total_products: store.total_products + successCount });
        
        res.json({
          success: true,
          message: `Bulk upload completed. ${successCount} products created, ${errorCount} errors.`,
          data: {
            successCount,
            errorCount,
            results: results.slice(0, 10), // Return first 10 for preview
            errors: errors.slice(0, 10) // Return first 10 errors for preview
          }
        });
      })
      .on('error', (error) => {
        // Clean up uploaded file
        if (req.file && req.file.path) {
          fs.unlinkSync(req.file.path);
        }
        
        res.status(500).json({
          success: false,
          message: 'Error processing CSV file',
          error: error.message
        });
      });
      
  } catch (error) {
    // Clean up uploaded file
    if (req.file && req.file.path) {
      fs.unlinkSync(req.file.path);
    }
    
    console.error('Bulk upload products error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to process bulk upload',
      error: error.message
    });
  }
};

// Get products by store
exports.getProductsByStore = async (req, res) => {
  try {
    const { store_id } = req.params;
    const { page = 1, limit = 10, search = '', category_id = '' } = req.query;
    const offset = (page - 1) * limit;
    
    // Check if store exists
    const store = await Store.findByPk(store_id);
    if (!store) {
      return res.status(404).json({
        success: false,
        message: 'Store not found'
      });
    }
    
    // Build where clause
    const whereClause = { store_id };
    if (search) {
      whereClause[Op.or] = [
        { name: { [Op.like]: `%${search}%` } },
        { description: { [Op.like]: `%${search}%` } },
        { product_code: { [Op.like]: `%${search}%` } }
      ];
    }
    
    if (category_id) {
      whereClause.category_id = category_id;
    }
    
    // Get products with count
    const { count, rows: products } = await Product.findAndCountAll({
      where: whereClause,
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [['createdAt', 'DESC']],
      include: [
        {
          model: Category,
          as: 'category',
          attributes: ['id', 'name']
        },
        {
          model: SubCategory,
          as: 'subCategory',
          attributes: ['id', 'name']
        }
      ]
    });
    
    res.json({
      success: true,
      data: {
        store,
        products,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(count / limit),
          totalItems: count,
          itemsPerPage: parseInt(limit)
        }
      }
    });
  } catch (error) {
    console.error('Get products by store error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch store products',
      error: error.message
    });
  }
};

// Toggle product status
exports.toggleProductStatus = async (req, res) => {
  try {
    const { id } = req.params;
    
    const product = await Product.findByPk(id);
    if (!product) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }
    
    const newValue = !product.is_active;
    await product.update({ is_active: newValue });
    
    res.json({
      success: true,
      message: 'Product status updated successfully',
      data: { isActive: newValue }
    });
  } catch (error) {
    console.error('Toggle product status error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to toggle product status',
      error: error.message
    });
  }
};

// Toggle product featured status
exports.toggleProductFeatured = async (req, res) => {
  try {
    const { id } = req.params;
    
    const product = await Product.findByPk(id);
    if (!product) {
      return res.status(404).json({
        success: false,
        message: 'Product not found'
      });
    }
    
    const newValue = !product.is_featured;
    await product.update({ is_featured: newValue });
    
    res.json({
      success: true,
      message: 'Product featured status updated successfully',
      data: { isFeatured: newValue }
    });
  } catch (error) {
    console.error('Toggle product featured error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to toggle product featured status',
      error: error.message
    });
  }
};

// Export products
exports.exportProducts = async (req, res) => {
  try {
    const { store_id, category_id } = req.query;
    
    const whereClause = {};
    if (store_id) {
      whereClause.store_id = store_id;
    }
    if (category_id) {
      whereClause.category_id = category_id;
    }
    
    const products = await Product.findAll({
      where: whereClause,
      order: [['createdAt', 'DESC']],
      include: [
        {
          model: Store,
          as: 'store',
          attributes: ['name']
        },
        {
          model: Category,
          as: 'category',
          attributes: ['name']
        },
        {
          model: SubCategory,
          as: 'subCategory',
          attributes: ['name']
        }
      ]
    });
    
    // Format data for export
    const exportData = products.map(product => ({
      ID: product.id,
      'Product Code': product.product_code,
      'Amazon ASIN': product.amazon_asin,
      Name: product.name,
      'SKU ID': product.sku_id,
      Description: product.description,
      'Selling Price': product.selling_price,
      MRP: product.mrp,
      'Cost Price': product.cost_price,
      Quantity: product.quantity,
      'Packaging Length (cm)': product.packaging_length,
      'Packaging Breadth (cm)': product.packaging_breadth,
      'Packaging Height (cm)': product.packaging_height,
      'Packaging Weight (kg)': product.packaging_weight,
      'GST %': product.gst_percentage,
      'Store Name': product.store?.name || 'N/A',
      'Category': product.category?.name || 'N/A',
      'Sub Category': product.subCategory?.name || 'N/A',
      Status: product.is_active ? 'Active' : 'Inactive',
      Featured: product.is_featured ? 'Yes' : 'No',
      Rating: product.rating,
      'Total Reviews': product.total_reviews,
      'Total Sold': product.total_sold,
      'Created At': product.createdAt.toISOString().split('T')[0]
    }));
    
    res.json({
      success: true,
      data: exportData
    });
  } catch (error) {
    console.error('Export products error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to export products',
      error: error.message
    });
  }
};

// Export multer configuration for routes
exports.upload = upload;
